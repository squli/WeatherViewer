package ru.squel.weatherviewer.data.remote;

import android.content.Context;
import android.content.SharedPreferences;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.Loader;
import android.util.Log;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import ru.squel.weatherviewer.data.DataConstants;
import ru.squel.weatherviewer.data.WeatherDataSource;
import ru.squel.weatherviewer.data.WeatherForDay;
import ru.squel.weatherviewer.data.WeatherForecast;
import ru.squel.weatherviewer.data.WeatherForecastResponse;
import ru.squel.weatherviewer.utils.Injector;

import static android.content.Context.CONNECTIVITY_SERVICE;

/**
 * Created by sq on 23.07.2017.
 */
public class RemoteWeatherData implements WeatherDataSource, DataConstants, LoaderManager.LoaderCallbacks<String> {

    private final static String LOG_TAG = RemoteWeatherData.class.getSimpleName();

    private static final int LOADER_ID = 1;

    /// прогноз погоды
    private WeatherForecast weatherForecast = null;

    /// лоадер-менеджер активити или фрагмента, который запрашивает данные
    private LoaderManager mLoaderManager;

    /// что-то, реализующее интерфейс коллбэка, который будет
    /// вызван после получения данных
    private WeatherForecastResponse weatherForecastResponseCallback;

    /**
     * Конструктор, который получит лоадер-менеджера
     * для создания конкретного лоадера
     */
    public RemoteWeatherData(LoaderManager mLoaderManager) {
        this.mLoaderManager = mLoaderManager;
    }

    /**
     * Выполнить запрос к API
     * @param place - местоположение
     */
    public void weatherForecastRequest(String place) {
        Loader<String> loader;
        Bundle bundle = new Bundle();
        bundle.putString(RemoteDataLoader.ARG_URL, (
                new UrlCreator()).getUrl(place));

        loader = mLoaderManager.getLoader(LOADER_ID);

        if (loader != null && !loader.isReset()) {
            mLoaderManager.restartLoader(LOADER_ID, bundle, this);
        } else {
            mLoaderManager.initLoader(LOADER_ID, bundle, this);
        }

        loader = mLoaderManager.getLoader(LOADER_ID);
        loader.forceLoad();
    }

    /**
     * Установить колбэк получения данных
     * @param weatherForecastResponse
     */
    public void setWeatherForecastResponse(WeatherForecastResponse weatherForecastResponse) {
        this.weatherForecastResponseCallback = weatherForecastResponse;
    }

    @Override
    public boolean isAvaliable(@Nullable String place) {
        return isConnectAvailable();
    }

    /**
     * Instantiate and return a new Loader for the given ID.
     *
     * @param id   The ID whose loader is to be created.
     * @param args Any arguments supplied by the caller.
     * @return Return a new Loader instance that is ready to start loading.
     */
    @Override
    public Loader<String> onCreateLoader(int id, Bundle args) {
        Loader<String> loader = null;

        if (id == LOADER_ID) {
            loader = new RemoteDataLoader(Injector.instance().getAppContext(), args);
        }
        return loader;
    }

    /**
     * @param loader The Loader that has finished.
     * @param data   The data generated by the Loader.
     */
    @Override
    public void onLoadFinished(Loader<String> loader, String data) {

        Log.d(LOG_TAG, "onLoadFinished");

        JSONObject jsonObject;

        // проверить, что данные похожи на правду и сохранить в bundle
        try {
            jsonObject = new JSONObject(data);
        } catch (JSONException e) {
            e.printStackTrace();
            return;
        }
        // разобрать и сформировать переменную типа WeatherForecast
        convertJSONtoWeatherForecast(jsonObject);

        //если json получился, то можно сохранять
        saveToSharedPrefernces(data);

        /// если коллбэк получения данных установлен, то вызвать его реализацию
        if (this.weatherForecastResponseCallback != null) {
            this.weatherForecastResponseCallback.weatherForecastResponseCallback(this.weatherForecast);
        }
    }

    /**
     * Called when a previously created loader is being reset, and thus
     * making its data unavailable.  The application should at this point
     * remove any references it has to the Loader's data.
     *
     * @param loader The Loader that is being reset.
     */
    @Override
    public void onLoaderReset(Loader<String> loader) {

    }

    /**
     * Save data to shared preferences
     * @param str
     * @return
     */
    private boolean saveToSharedPrefernces(String str) {
        SharedPreferences sPref = Injector.instance().getAppContext().getSharedPreferences(DataConstants.SHARED_PREF_NAME, Context.MODE_PRIVATE);
        SharedPreferences.Editor ed = sPref.edit();

        ed.putString(DataConstants.SHARED_PREF_PLACE, this.weatherForecast.getPlace());
        ed.putString(DataConstants.SHARED_PREF_TIME, String.valueOf(System.currentTimeMillis()));
        ed.putString(DataConstants.SHARED_PREF_NAME, str);

        return ed.commit();
    }

    /**
     * Преобразовать JSON в прогноз погоды
      * @param jsonObject
     */
    private void convertJSONtoWeatherForecast (JSONObject jsonObject) {
        this.weatherForecast = new WeatherForecast();

        try {
            // Получение свойства "City" JSONArray
            JSONObject city = jsonObject.getJSONObject("city");
            this.weatherForecast.setPlace(city.getString("name"));

            // Получение свойства "list" JSONArray
            JSONArray list = jsonObject.getJSONArray("list");

            // Преобразовать каждый элемент списка в объект типа WeatherForDay
            for (int i = 0; i < list.length(); i++) {
                // данные за один день
                JSONObject day = list.getJSONObject(i);

                // Получить JSONObject с температурами дня ("temp")
                JSONObject temperatures = day.getJSONObject("temp");

                // Получить JSONObject c описанием и значком ("weather")
                JSONObject weather = day.getJSONArray("weather").getJSONObject(0);

                // Добавить новый объект Weather в weatherList
                WeatherForDay newDay = new WeatherForDay(
                        day.getLong("dt"),                  // Временная метка даты/времени
                        temperatures.getDouble("min"),
                        temperatures.getDouble("max"),
                        temperatures.getDouble("day"),
                        temperatures.getDouble("night"),
                        temperatures.getDouble("eve"),
                        temperatures.getDouble("morn"),
                        day.getDouble("pressure"),
                        day.getDouble("humidity"),
                        weather.getInt("id"),
                        weather.getString("main"),
                        weather.getString("description"),
                        weather.getString("icon"),
                        day.getDouble("speed"),
                        day.getInt("deg"),
                        day.getDouble("clouds"));
                try {
                    newDay.setRain(day.getDouble("rain"));
                }
                catch (Exception e) {

                }

                weatherForecast.add(newDay);
                }

        } catch (JSONException e) {
            e.printStackTrace();
        }
    }

    /**
     * Check internet connection
     * @return true if the internet available
     */
    private boolean isConnectAvailable(){
        boolean result = false;
        ConnectivityManager cm =
                (ConnectivityManager) Injector.instance().getAppContext().getSystemService(CONNECTIVITY_SERVICE);

        NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
        if (activeNetwork != null && activeNetwork.isConnectedOrConnecting()){
            result = true;
        }
        return result;
    }

}
